# -*- coding: utf-8 -*-
"""Untitled5.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ud9RxNmB9HG-FlMnrSf-ZLLc5g1l5-fK
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pandas.plotting import scatter_matrix
# %matplotlib inline
from copy import deepcopy as copy

from IPython.display import Latex
from IPython.display import Math

#url = "https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data"
#names = ['age', 'workclass', 'fnlwgt', 'education', 'educationNum','maritalStatus','occupation','relationship','race','sex','capitalGain','capitalLoss','hoursPerWeek','nativeCountry','Output']
df = pd.read_csv('adult.csv')
df

df.shape

df.columns

df.describe()

df.isnull().sum()

#Missing Values are represented as Question Marks in this Dataset.
print("No of Missing Values in each categorical column ")
print(f"workclass : {sum(df['workclass']=='?')}")
print(f"education : {sum(df['education']=='?')}")
print(f"marital.status : {sum(df['marital.status']=='?')}")
print(f"occupation : {sum(df['occupation']=='?')}")
print(f"relationship : {sum(df['relationship']=='?')}")
print(f"race : {sum(df['race']=='?')}")
print(f"sex : {sum(df['sex']=='?')}")
print(f"native.country : {sum(df['native.country']=='?')}")
print(f"income : {sum(df['income']=='?')}")

#Removing Missing Values:
df1 = df[(df['workclass']!='?')&(df['occupation']!='?')&(df['native.country']!='?')].copy(deep = True)
df1.head()

df1.isnull().sum()

df1["income"].unique()

df1.shape

df1.info()

df1

# Identify Numeric features
numeric_features = ['age','fnlwgt','education.num','capital.gain','capital.loss','hours.per.week']

# Identify Categorical features
cat_features = ['workclass','education','marital.status', 'occupation', 'relationship', 'race', 'sex', 'native.country', 'income']

df1.head()

df1["income"].value_counts()

import seaborn as sns
g = sns.pairplot(df)
g.fig.set_size_inches(40,40)

import matplotlib.pyplot as plt
sns.countplot(x="income", data=df)
plt.figure(figsize=(20,10))

fig, ax = plt.subplots(nrows=2,ncols=3, figsize=(40,30))
sns.countplot(x="sex", data=df1,hue="income",ax = ax[0][0])
cp = sns.countplot(x="marital.status", data=df1,hue="income",ax = ax[0][1])
cp.set_xticklabels(cp.get_xticklabels(), rotation=40, ha="right")
cp2 = sns.countplot(x="education", data=df1,hue="income",ax = ax[0][2])
cp2.set_xticklabels(cp2.get_xticklabels(), rotation=40, ha="right")
cp3 = sns.countplot(x="race", data=df1,hue="income",ax = ax[1][0])
cp3.set_xticklabels(cp3.get_xticklabels(), rotation=40, ha="right")
cp4 = sns.countplot(x="relationship", data=df1,hue="income", ax = ax[1][1])
cp4.set_xticklabels(cp4.get_xticklabels(), rotation=40, ha="right")
cp5 = sns.countplot(x="occupation", data=df1,hue="income",ax= ax[1][2])
cp5.set_xticklabels(cp5.get_xticklabels(), rotation=40, ha="right")

plt.tight_layout()

viol_plot = sns.catplot(x="race", y="fnlwgt", hue="income",data=df1, kind="violin")
viol_plot.ax.legend(loc=2)
viol_plot.set_xticklabels(rotation=30,ha = "right")
plt.tight_layout()

g = sns.catplot(x="occupation", y="fnlwgt", hue="income", data=df1)
g.set_xticklabels(rotation=30,ha = "right")
plt.tight_layout()

#Box plots

df1.drop(['education.num','income'],axis = 1).plot(kind='box', subplots=True, layout=(2,3), sharex=False, sharey=False,
        figsize=(9,9),title='Box Plot of Income variable')

ax = sns.catplot(x="workclass", y="capital.gain", kind="box", data=df1);
ax.set_xticklabels(rotation=30,ha = "right")
plt.tight_layout()

# Distribution Plots:
sns.distplot(df1['age'],kde = False,bins = 30)

plt.hist(x = df1['age'],histtype='bar',facecolor = 'g')

sns.distplot(df1['education.num'],kde = False)

sns.distplot(df1['hours.per.week'],kde = False)

sns.jointplot(x ="age", y="hours.per.week", data=df1,kind="hex")
#sns.jointplot(x='total_bill',y='tip',data=tips,kind='hex')
#kind must be either 'scatter', 'reg', 'resid', 'kde', or 'hex

sns.regplot(x='capital.gain', y='capital.loss',data = df1, marker="+")

sns.jointplot(x="hours.per.week",y ="fnlwgt",data=df1,kind="scatter")

sns.jointplot(x="fnlwgt", y="age", data=df1, kind="kde")

cr = df1.corr()
sns.heatmap(cr,annot=True,cmap = 'YlOrBr')

def outL_func(q25,q75):
    return (q75 + 1.5*(q75-q25))

def outR_func(q25,q75):
    return (q25 - 1.5*(q75-q25))

def out_rem(x,outL,outR):
    if x>outR:
        return outR

    elif x<outL:
        return outL
    else :
        return x

import numpy as np
df1.head()

labels = ['age','fnlwgt','hours.per.week']
for label in labels :
    q25,q75 = q75, q25 = np.percentile(df1[label], [75,25])
    outL = outL_func(q25,q75)
    outR = outR_func(q25,q75)
    df1[label]= df1[label].apply(lambda row: out_rem(row,outL,outR))

from sklearn import preprocessing

le = preprocessing.LabelEncoder()
df1['workclass'] = le.fit_transform(df1['workclass'])
df1['education'] = le.fit_transform(df1['education'])
df1['marital.status'] = le.fit_transform(df1['marital.status'])
df1['occupation'] = le.fit_transform(df1['occupation'])
df1['relationship'] = le.fit_transform(df1['relationship'])
df1['race'] = le.fit_transform(df1['race'])
df1['sex'] = le.fit_transform(df1['sex'])
df1['native.country'] = le.fit_transform(df1['native.country'])

df1["income"]= df1["income"].apply(lambda x: -1 if x == '<=50K' else 1  )
df1

df1['income'].value_counts()
df1.head()

t=df1.income
t=t.values.reshape(-1,1)
t

X=df1[:]
X=X.drop(['income'], axis=1)
X.shape

X.shape

t.shape

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, t, test_size=0.30, random_state=42)

from sklearn.linear_model import LogisticRegression

model1 = LogisticRegression().fit(X_train, y_train)

y_predict=model1.predict(X_test)
#pred_model2=model2.predict(X_test)
print("Logistic Regression Score : ",model1.score(X_test, y_test))

from sklearn.metrics import precision_score, recall_score, confusion_matrix, classification_report,accuracy_score, f1_score
cf=confusion_matrix(y_test, y_predict)
TP=cf[1][1]
TN=cf[0][0]
FN=cf[1][0]
FP=cf[0][1]
sns.heatmap(confusion_matrix(y_test, y_predict),cmap='Reds', annot=True, fmt='d')
plt.title("Logistic Regression Confusion Matrix")

print('Accuracy on test:', accuracy_score(y_test,y_predict),"\n")
print('F1 score on test:', f1_score(y_test,y_predict),"\n")
precision=(TP/(TP+FP))
print("Precision :" , precision,"\n")
specificity=TN/(TN+FP)
print("Specificity :" , specificity,"\n")
recall=TP/(TP+FN)
print("Recall :" , recall,"\n")

plt.title("Y prediction")
plt.plot(y_predict[0:100])
plt.show()
plt.title("Y test")
plt.plot(y_test[0:100])
plt.show()
plt.title("Y pred vs Y test")
plt.plot(y_predict[0:100])
plt.plot(y_test[0:100])
plt.show()

from sklearn.metrics import roc_auc_score, roc_curve, auc
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_predict)
roc_auc = auc(false_positive_rate, true_positive_rate)
plt.plot(false_positive_rate, true_positive_rate, 'b',
label='AUC = %0.4f'% roc_auc)
plt.legend(loc='lower right')
plt.plot([0,1],[0,1],'r--')
plt.xlim([-0.1,1.5])
plt.ylim([-0.1,1.5])
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()
print("ROC AUC Score : ", roc_auc_score(y_test, y_predict))